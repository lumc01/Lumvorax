--- competitor_old_f26d45

+++ competitor_new_latest

@@ -20,26 +20,26 @@

 os.environ.setdefault("NUMEXPR_NUM_THREADS", "4")
 
-import subprocess
-from pathlib import Path
-
-var = Path("/kaggle/input/vsdetection-packages-offline-installer-only/whls")
-whl_patterns = [
-    "keras_nightly-*.whl",
-    "tifffile-*.whl",
-    "imagecodecs-*.whl",
-    "medicai-*.whl",
-]
-whls = []
-for pat in whl_patterns:
-    found = sorted(var.glob(pat))
-    if not found:
-        raise FileNotFoundError(f"Missing wheel for pattern: {pat} in {var}")
-    whls.append(str(found[0]))
-
-subprocess.check_call([
-    "python", "-m", "pip", "install", *whls,
-    "--no-index", "--find-links", str(var)
-])
+var="/kaggle/input/vsdetection-packages-offline-installer-only/whls"
+!pip install \
+  "$var"/keras_nightly-*.whl \
+  "$var"/tifffile-*.whl \
+  "$var"/imagecodecs-*.whl \
+  "$var"/medicai-*.whl \
+  --no-index \
+  --find-links "$var"
 clear_output()
+
+# --- Protobuf compatibility patch (MessageFactory.GetPrototype) ---
+try:
+    from google.protobuf import message_factory as _message_factory
+    if not hasattr(_message_factory.MessageFactory, "GetPrototype"):
+        from google.protobuf.message_factory import GetMessageClass
+        def _GetPrototype(self, descriptor):
+            return GetMessageClass(descriptor)
+        _message_factory.MessageFactory.GetPrototype = _GetPrototype
+        print("Patched protobuf: added MessageFactory.GetPrototype")
+except Exception as e:
+    print("Could not patch protobuf MessageFactory:", e)
+
 
 import time, zipfile
@@ -87,17 +87,4 @@

     # warmup
     DO_WARMUP=True,
-
-)
-
-# SHF/RSR overlay isolated from competitor baseline config
-# Baseline-safe defaults: disabled unless explicitly enabled
-LUM_CFG = dict(
-    # synchronized with competitor baseline parameters
-    USE_LUM_RESONANCE=True,
-    LUM_BLEND_ALPHA=CFG["overlap_base"],
-    LUM_SPECTRAL_GAMMA=CFG["overlap_hi"],
-    LUM_PRIOR_WEIGHT=CFG["overlap_public"],
-    LUM_SMOOTH_STEPS=CFG["z_radius"],
-    LUM_PRIOR_THRESHOLD=CFG["T_low"],
 )
 
@@ -154,41 +141,4 @@

     else:
         raise ValueError(f"Unknown INK_MODE={mode}")
-
-# ----------------------------
-# LUM/VORAX SHF-RSR helpers
-# ----------------------------
-def shf_spectral_signature(prob):
-    p = np.asarray(prob, dtype=np.float32)
-    fft_mag = np.abs(np.fft.rfftn(p)).astype(np.float32, copy=False)
-    hi = float(np.percentile(fft_mag, 92.0))
-    lo = float(np.percentile(fft_mag, 60.0))
-    score = hi / (lo + 1e-6)
-    return float(np.clip(score, 0.0, 8.0))
-
-def rsr_recursive_prior(pub_fg_bool, smooth_steps=2):
-    prior = pub_fg_bool.astype(np.float32, copy=False)
-    for _ in range(max(0, int(smooth_steps))):
-        prior = ndi.gaussian_filter(prior, sigma=(0.0, 1.2, 1.2))
-        prior = np.clip(prior, 0.0, 1.0)
-    return prior
-
-def lum_resonance_blend(prob, pub_fg_bool, lum_cfg):
-    spectral = shf_spectral_signature(prob)
-    spectral_gain = np.clip((spectral - 1.0) * lum_cfg["LUM_SPECTRAL_GAMMA"], 0.0, 1.0)
-
-    prior = rsr_recursive_prior(pub_fg_bool, smooth_steps=lum_cfg["LUM_SMOOTH_STEPS"])
-    prior_gate = (prior >= lum_cfg["LUM_PRIOR_THRESHOLD"]).astype(np.float32)
-
-    alpha = float(lum_cfg["LUM_BLEND_ALPHA"])
-    w_prior = float(lum_cfg["LUM_PRIOR_WEIGHT"])
-    blended = prob * (1.0 - alpha) + alpha * ((1.0 - w_prior) * prob + w_prior * prior_gate)
-    boosted = np.clip(blended + spectral_gain * prior * 0.08, 0.0, 1.0).astype(np.float32, copy=False)
-
-    return boosted, {
-        "lum_spectral_score": float(spectral),
-        "lum_spectral_gain": float(spectral_gain),
-        "lum_prior_mean": float(prior.mean()),
-        "lum_prior_gate_rate": float(prior_gate.mean()),
-    }
 
 # ----------------------------
@@ -355,9 +305,7 @@

       f"overlap_public={CFG['overlap_public']}, overlap_base={CFG['overlap_base']}, overlap_hi={CFG['overlap_hi']},",
       f"INK_MODE={CFG['INK_MODE']}, T_low={CFG['T_low']}, T_high={CFG['T_high']},",
-      f"OV06_MAIN_ONLY={CFG['OV06_MAIN_ONLY']},",
-      f"USE_LUM_RESONANCE={LUM_CFG['USE_LUM_RESONANCE']}")
+      f"OV06_MAIN_ONLY={CFG['OV06_MAIN_ONLY']}")
 
 t_global0 = time.perf_counter()
-run_rows = []
 
 with zipfile.ZipFile(zip_path, "w", compression=zipfile.ZIP_DEFLATED) as zf:
@@ -378,17 +326,7 @@

         pub_fg = (pub_labels != 0)
 
-        lum_metrics = {
-            "lum_spectral_score": 0.0,
-            "lum_spectral_gain": 0.0,
-            "lum_prior_mean": 0.0,
-            "lum_prior_gate_rate": 0.0,
-        }
-        prob_for_output = prob
-        if LUM_CFG["USE_LUM_RESONANCE"]:
-            prob_for_output, lum_metrics = lum_resonance_blend(prob, pub_fg, LUM_CFG)
-
         # single final path
         output = seeded_hysteresis_with_topology(
-            prob_for_output,
+            prob,
             pub_fg_bool=pub_fg,
             T_low=CFG["T_low"],
@@ -406,19 +344,5 @@

         dt = time.perf_counter() - t0
         elapsed = time.perf_counter() - t_global0
-        run_rows.append({
-            "id": image_id,
-            "positives": int(output.sum()),
-            **lum_metrics,
-            "minutes": float(dt / 60.0),
-        })
-        print(f"[{i+1}/{len(ids)}] id={image_id} | {dt/60:.2f} min | elapsed {elapsed/3600:.2f} h | positives={int(output.sum())} | lum_score={lum_metrics['lum_spectral_score']:.3f}")
-
-if run_rows:
-    run_df = pd.DataFrame(run_rows)
-    print("\nLUM resonance summary:")
-    print(run_df[["id", "positives", "lum_spectral_score", "lum_spectral_gain", "lum_prior_mean", "lum_prior_gate_rate", "minutes"]].to_string(index=False))
+        print(f"[{i+1}/{len(ids)}] id={image_id} | {dt/60:.2f} min | elapsed {elapsed/3600:.2f} h | positives={int(output.sum())}")
 
 print("Submission ZIP:", zip_path)
-
-
-