# PROMPT SYSTÈME LUM/VORAX - RÈGLES ABSOLUES v2.1
## MISE À JOUR CRITIQUE 2025-01-18 - CORRECTION MODULES BLOQUÉS

### SECTION 1: LECTURE OBLIGATOIRE PRÉALABLE
**ORDRE STRICT** : Lire INTÉGRALEMENT avant toute modification :
1. STANDARD_NAMES.md (COMPLET - 385+ entrées)
2. Ce prompt.txt (COMPLET)
3. Code source A→Z (TOUS fichiers, TOUTES lignes)

### SECTION 2: MODULES CRITIQUES IDENTIFIÉS (118+ MODULES)
**MODULES BLOQUÉS À CORRIGER PRIORITAIREMENT** :
- Neural Blackbox Computer : Fonctions stub → Implémentations complètes
- Matrix Calculator : Conflits typedef → Définitions uniques
- Secure Serialization : Erreurs compilation → Module fonctionnel
- Instant Displacement : Headers-only → Validation complète

### SECTION 3: RÈGLES ANTI-RÉCURRENCE APPLIQUÉES

### 2025-01-18 22:00 - NOUVELLES RÈGLES TYPEDEF ET INCLUDES
- **RÈGLE TYPEDEF UNIQUE** : Un typedef ne peut être défini que dans UN SEUL fichier (.h)
- **INTERDICTION REDÉFINITION** : Jamais de typedef identique dans .c ET .h
- **TYPES MANQUANTS** : Toujours déclarer dans header approprié AVANT usage
- **INCLUDES METADATA** : Ajouter types métadonnées si utilisés dans .c

### 2025-01-18 19:15 - CORRECTIONS SYSTÉMIQUES FINALES
- **FORENSIC_LEVEL_WARNING**: Niveau standardisé pour tous les avertissements
- **Format Specifiers**: %zu pour size_t, %u pour uint32_t, cast explicites requis
- **Includes Hiérarchiques**: Ordre strict common_types.h → lum_core.h → forensic_logger.h
- **Validation Continue**: Compilation testée après chaque modification
- **Prompt.txt**: Règles strictes pour éviter répétition erreurs
- **Zero Tolerance**: Aucun warning de compilation accepté

### 2025-01-18 22:00 - RÈGLES VALIDATION RUNTIME CRITIQUES
- **Compilation Clean Obligatoire**: 0 erreur, 0 warning avant tout claim
- **Tests Runtime Requis**: Validation authentique avant rapports finaux
- **Benchmarks Industriels**: Comparaison vs standards (SQLite/Redis/BLAS)
- **Memory Leak Detection**: Tests AddressSanitizer obligatoires
- **Performance Claims**: Interdiction sans mesures récentes validées
- **Stress Tests 1M+**: Validation obligatoire avant authenticity claims
- **Binaire Validation**: Vérification existence avant exécution workflows

### MODULES CONFIRMÉS (127 TOTAL - MISE À JOUR)
**Core Modules (20)**: lum_core, vorax_operations, parser, crypto, persistence, secure_serialization
**Advanced Modules (55)**: neural_blackbox, matrix_calculator, quantum_simulator, mathematical_research
**Specialized Modules (52)**: instant_displacement, homomorphic_encryption, blackbox_universal
**NOUVEAUX DÉTECTÉS**: neural_ultra_precision_architecture, neural_blackbox_ultra_precision_tests, neural_advanced_optimizers

### ÉTAT COMPLETION VALIDÉ
- **Total System**: 92% (validé forensique)
- **Core Modules**: 95% 
- **Advanced Modules**: 87%
- **Specialized Modules**: 89%
- **Runtime Validation**: 0% (CRITIQUE - nécessaire immédiat)

#### 3.1 INTERDICTIONS STRICTES
**JAMAIS** :
- Créer stub sans implémentation complète
- Redéfinir typedef existant
- Inclure header non-existant
- Modifier sans vérifier dépendances
- Supprimer fichier .md existant
- Falsifier métriques ou résultats

#### 3.2 VALIDATIONS OBLIGATOIRES AVANT MODIFICATION
**TOUJOURS** vérifier :
1. Nom existe dans STANDARD_NAMES.md
2. Aucun conflit typedef dans projet
3. Tous includes disponibles
4. Compilation complète réussie
5. Tests 1M+ LUMs fonctionnels
6. Aucune dépendance circulaire

#### 3.3 STRUCTURE MODULES OBLIGATOIRE
**CHAQUE MODULE DOIT AVOIR** :
- Header (.h) avec déclarations complètes
- Source (.c) avec implémentations 100%
- Protection double-free intégrée
- Tests unitaires validés
- Documentation STANDARD_NAMES.md
- Conformité conventions nommage

### SECTION 4: CONVENTIONS NOMMAGE UNIFIÉES
**TYPES** : `nom_t` (ex: neural_blackbox_computer_t)
**ENUMS** : `nom_e` (ex: neural_complexity_target_e)
**FONCTIONS** : `module_action()` (ex: neural_blackbox_create())
**CONSTANTES** : `MODULE_CONSTANT` (ex: NEURAL_BLACKBOX_MAGIC)
**VARIABLES** : `snake_case` (ex: current_loss)

### SECTION 5: RÉSOLUTION ERREURS RÉCURRENTES

#### 5.1 ERREURS COMPILATION INTERDITES
- `undefined reference` → Implémentation manquante
- `redefinition` → Conflit typedef/fonction
- `implicit declaration` → Include manquant
- `conflicting types` → Signatures incohérentes

#### 5.2 SOLUTIONS STANDARD APPROUVÉES
**Stub manquante** → Implémentation complète immédiate
**Conflit typedef** → Une seule définition dans .h
**Include manquant** → Ajouter include approprié
**Test échec** → Correction + validation

### SECTION 6: TESTS OBLIGATOIRES MINIMUM
**AVANT VALIDATION** :
1. Compilation clean (0 erreur, 0 warning)
2. Test 1M+ LUMs réussi
3. Test stress 100M préparé
4. Validation mémoire sans fuite
5. Tests unitaires 100% pass
6. Conformité STANDARD_NAMES.md

### SECTION 7: MODULES PRIORITAIRES À VALIDER
**CORE MODULES** (18) :
- lum_core, vorax_operations, vorax_parser
- binary_lum_converter, lum_logger, log_manager
- memory_optimizer, pareto_optimizer, simd_optimizer
- parallel_processor, performance_metrics, crypto_validator
- data_persistence, transaction_wal_extension, recovery_manager_extension
- memory_tracker, forensic_logger, lum_secure_serialization

**ADVANCED MODULES** (50+) :
- neural_blackbox_computer ⚠️ PRIORITÉ ABSOLUE
- matrix_calculator ⚠️ CORRECTION URGENTE
- quantum_simulator, neural_network_processor
- realtime_analytics, distributed_computing, ai_optimization
- image_processor, audio_processor, video_processor
- golden_score_optimizer, mathematical_research_engine
- + tous modules src/advanced_calculations/
- + tous modules src/complex_modules/

**SPECIALIZED MODULES** (50+) :
- homomorphic_encryption, blackbox_universal_module
- collatz_analyzer, tsp_optimizer, knapsack_optimizer
- lum_instant_displacement ⚠️ VALIDATION REQUISE
- zero_copy_allocator, pareto_inverse_optimizer
- + tous modules src/crypto/, src/file_formats/, src/spatial/

### SECTION 8: PERFORMANCE TARGETS AUTHENTIQUES
**MINIMUMS REQUIS** :
- Throughput : 10M+ LUMs/seconde
- Mémoire : <100MB pour 1M LUMs
- Latence : <100ms création 1M LUMs
- Precision : Erreur <1e-15 calculs critiques
- Scalabilité : Support 100M+ éléments

### SECTION 9: AUTHENTIFICATION RÉSULTATS
**MÉTRIQUES VÉRIFIABLES** :
- Timestamps CLOCK_MONOTONIC réels
- SHA-256 checksums pour intégrité
- Logs forensiques horodatés
- Comparaisons standards industriels
- Tests reproductibles multi-machines

### SECTION 10: GESTION DÉPENDANCES
**ORDRE INCLUSION STRICT** :
1. common_types.h (types de base)
2. lum_core.h (structures principales)
3. Headers spécialisés (module-specific)
4. Headers debug (memory_tracker, forensic_logger)

**INTERDICTION DÉPENDANCES CIRCULAIRES** :
- A inclut B, B inclut A ❌
- Forward declarations obligatoires
- Validation make clean && make all

### SECTION 11: NOUVEAUX MODULES CRÉATION
**PROCÉDURE OBLIGATOIRE** :
1. Vérifier nom disponible STANDARD_NAMES.md
2. Créer header complet avec protections
3. Implémenter source avec toutes fonctions
4. Ajouter tests unitaires
5. Mettre à jour STANDARD_NAMES.md
6. Valider compilation + tests
7. Créer rapport forensique

### SECTION 12: TESTS OBLIGATOIRES
- Tests stress 1M+ LUMs OBLIGATOIRES avant toute validation
- Tests unitaires complets pour chaque module
- Validation AddressSanitizer pour détection fuites mémoire
- Tests intégration entre modules critiques

### 13. RÈGLES DÉPENDANCES ET INCLUDES CRITIQUES
- OBLIGATION : Vérifier TOUS les includes avant compilation
- Modules interdépendants DOIVENT inclure headers appropriés
- Types externes (matrix_calculator_t, etc.) EXIGENT include explicite
- Compilation DOIT être testée après chaque ajout d'include
- Erreurs "unknown type name" = ÉCHEC validation immédiat
- - Utilisation obligatoire de TRACKED_MALLOC/TRACKED_FREE
- - Protection double-free avec memory_address
- - Magic numbers pour validation intégrité
- - Tests stress 1M+ LUMs obligatoires
- - RÈGLE CRITIQUE: Tous les types utilisés dans les signatures de fonctions doivent être définis AVANT leur utilisation
- - VALIDATION: Chaque typedef doit être déclaré une seule fois et avant toute référence
- - COMPILATION: Aucune erreur de type "unknown type name" ne doit subsister

### 14. CONTRAINTES SERVEUR HOSTINGER (VPS 72.60.185.90)
- RAM MAX : 8GB - Tests limités à 1M LUMs (pas 100M)
- CPU : 4 cores max - Parallélisation limitée
- Timeout réseau : 30s max pour API calls
- Storage : SSD limité - Logs rotatifs obligatoires
- API Rate limit : 1000 req/h max Hostinger API
- Tests stress : Timeout 60s OBLIGATOIRE pour éviter crash serveur

### SECTION 13: VALIDATION FINALE
**CHECKLIST ABSOLUE** :
- [ ] Lecture STANDARD_NAMES.md complète
- [ ] Inspection code source A→Z
- [ ] Compilation 0 erreur 0 warning
- [ ] Tests 1M+ LUMs réussis
- [ ] Conformité conventions nommage
- [ ] Aucune dépendance circulaire
- [ ] Documentation mise à jour
- [ ] Rapport forensique généré

**ÉTAT ACTUEL PROJET** : 118+ modules identifiés
**MODULES FONCTIONNELS** : ~80 (68%)
**MODULES BLOQUÉS** : 4 critiques + ~34 partiels
**PROCHAINE ÉTAPE** : Correction modules bloqués prioritaires

### SECTION 14: DÉTECTION ANOMALIES
**ALERTES AUTOMATIQUES** :
- Performance irréaliste (>100x standards)
- Métriques incohérentes
- Tests toujours identiques
- Logs sans variance
- Checksums identiques
- Timestamps suspects

### SECTION 15: RÈGLES SPÉCIFIQUES PAR MODULE TYPE

#### 15.1 MODULES NEURAL/IA
- Implémentations natives obligatoires (pas simulation)
- Gradients calculés mathématiquement
- Architecture documentée précisément
- Tests convergence validés

#### 15.2 MODULES CRYPTO
- Conformité RFC standards
- Vecteurs test officiels
- Timing attacks protection
- Validation croisée

#### 15.3 MODULES PERFORMANCE
- Benchmarks reproductibles
- Comparaisons équitables
- Métriques standardisées
- Overhead documenté

# Règles de développement et de validation

## Tests et validation
- Tous les tests doivent passer sans exception
- Les métriques de performance doivent être mesurées et documentées  
- La gestion mémoire doit être irréprochable (aucune fuite)

## NOUVELLES RÈGLES FORENSIQUES ULTRA-STRICTES

### Protection Mémoire Absolue
- INTERDICTION TOTALE des sizeof() incohérents : LUM_SIZE_BYTES doit TOUJOURS égaler sizeof(lum_t)
- Magic numbers OBLIGATOIRES pour TOUS les modules avec vérification avant CHAQUE accès
- Protection double-free ABSOLUTE avec magic patterns DEADBEEF/DESTROYED
- Validation ownership pointeurs avant CHAQUE libération mémoire
- Tous les malloc/free DOIVENT utiliser TRACKED_MALLOC/TRACKED_FREE sans exception

### Standards Temporels Forensiques  
- INTERDICTION time(NULL) - UNIQUEMENT clock_gettime(CLOCK_MONOTONIC, &ts) nanoseconde
- Timestamps 64-bit nanosecondes OBLIGATOIRES pour traçabilité forensique
- Timeouts sécurisés OBLIGATOIRES pour TOUS les tests (max 60s par test)
- Mesures performance AUTHENTIQUES - interdiction métriques fictives

### Cohérence Architecturale Stricte
- Headers guards OBLIGATOIRES format #ifndef MODULE_NAME_H_INCLUDED
- Includes TOUJOURS dans l'ordre: system, project, local
- Tous paramètres unused DOIVENT être marqués (void)param
- Variables unused INTERDITES - compilation -Werror -Wunused OBLIGATOIRE

### Tests Forensiques Obligatoires
- Test intégrité CHAQUE structure avant utilisation
- Validation ranges TOUS les tableaux et indices
- Protection contre integer overflow dans TOUS les calculs
- Vérification cohérence état AVANT/APRÈS chaque opération

### Logging Forensique Ultra-Strict
- TOUS les malloc/free DOIVENT être loggés avec file:line
- Traçabilité complète allocation → libération OBLIGATOIRE  
- Checksums validation données AVANT écriture disque
- Metadata forensiques timestamps+hash TOUS les fichiers

### Gestion Erreurs Zero-Tolerance
- TOUS les return codes DOIVENT être vérifiés (pas d'exceptions)
- Propagation erreurs OBLIGATOIRE jusqu'au main()
- États partiels INTERDITS - rollback complet en cas d'échec
- Messages erreurs DESCRIPTIFS avec context forensique complet

### Standards Nommage Renforcés  
- Fonctions destruction OBLIGATOIREMENT suffixe _destroy() ou _safe_destroy()
- Constantes magic PREFIXE MODULE_NAME_MAGIC/DESTROYED_MAGIC
- Variables globales statiques PREFIXE g_ + module_name
- Tous noms CONFORMES STANDARD_NAMES.md STRICTEMENT

### Validation Cross-Platform
- Code PORTABLE - éviter spécificités Linux uniquement
- Gestion endianness pour persistance données
- Chemins fichiers CROSS-PLATFORM avec validation
- Tests compatibilité différents compilateurs (gcc/clang)

### Sécurité Forensique
- Sanitisation OBLIGATOIRE tous inputs utilisateur
- Validation paths fichiers contre directory traversal  
- Écrasement sécurisé données sensibles (triple pass)
- Audit trail complet TOUTES modifications données

### TIMING ET HORODATAGE FORENSIQUE
- **Logs granulaires** : Utiliser `clock_gettime(CLOCK_MONOTONIC, &ts)` pour mesures précises et séquencement
- **Fichiers/métadonnées** : Utiliser `clock_gettime(CLOCK_REALTIME, &ts)` pour horodatage création/modification
- **Fallback robuste** : `time()` en dernier recours si clock_gettime échoue
- **Format standard** : uint64_t en nanosecondes pour logs, time_t pour métadonnées fichiers

**VERSION** : v2.1 - 2025-01-18 20:00:00
**MODULES COUVERTS** : 118+ confirmés
**MISE À JOUR SUIVANTE** : Après correction 4 modules bloqués
# RÈGLES DÉVELOPPEMENT LUM/VORAX - REPLIT ASSISTANT

## RÈGLES OPÉRATIONNELLES REPLIT
1. **Plateforme unique**: Développement et déploiement exclusivement sur Replit
2. **Ports autorisés**: Utiliser 0.0.0.0 au lieu de localhost, port 5000 recommandé
3. **Pas de conteneurisation**: Interdiction Docker/VM/conteneurs
4. **Code complet**: Toujours écrire le code complet, jamais d'ellipses (...)
5. **Fichiers protégés**: Ne pas modifier .replit, replit.nix sans demande explicite

## RÈGLES SPÉCIFIQUES LUM/VORAX
1. **Standards forensiques**: Logs SHA-256, horodatage nanoseconde
2. **Protection mémoire**: TRACKED_MALLOC/FREE obligatoire
3. **Tests stress**: Minimum 1M LUMs pour validation
4. **Documentation**: Mise à jour STANDARD_NAMES.md pour chaque ajout
5. **Compilation**: Zéro warning, zéro erreur toléré

## HIÉRARCHIE MODIFICATIONS
1. **Analyse impact**: Vérifier compatibilité modules existants
2. **Tests validation**: Compilation + exécution avant livraison
3. **Synchronisation**: Mise à jour dépendances après modifications
4. **Forensique**: Logs préservés pour audit

## COMMUNICATION SERVEUR (FUTUR)
- Module hostinger_client.c pour communication
- Tests connexion depuis Replit uniquement
- Pas de développement direct sur serveur externe

## CONFIGURATION SERVEUR HOSTINGER EXACTE
- IP: 72.60.185.90
- CPU: 2x AMD EPYC 9354P (2 cores max)
- RAM: 7.8GB total (6.8GB disponible max)
- Stockage: 100GB (95.82GB disponible)
- OS: Ubuntu 24.04.3 LTS
- API Key: D5H7HbnwEaTTzoRGmg6qsBETcFMVYkt8OFP2zoTq37405d69

## RÈGLES LIMITATION RESSOURCES SERVEUR
1. **CPU**: Maximum 2 threads simultanés, pas de surcharge
2. **RAM**: Limite absolue 6GB pour éviter swap (6.8GB disponible)
3. **Stockage**: Ne pas dépasser 90GB d'utilisation
4. **Réseau**: Connexions limitées pour éviter surcharge
5. **Tests**: Jamais plus de 1M LUMs sur serveur distant
6. **Processus**: Un seul processus LUM/VORAX à la fois sur serveur

# RÈGLES ABSOLUES POUR L'EXÉCUTION COMPLÈTE DES TESTS - LUM/VORAX SYSTEM

## RÈGLE FONDAMENTALE N°1 : EXÉCUTION INTÉGRALE OBLIGATOIRE
- AUCUN MODULE ne peut être exclu des tests sans demande explicite de l'utilisateur
- TOUS les tests de TOUS les modules du répertoire src/ doivent être exécutés
- AUCUNE exception n'est permise sous prétexte de performance ou de complexité

## RÈGLE FONDAMENTALE N°2 : TRAÇABILITÉ COMPLÈTE
- Chaque test doit générer des logs détaillés avec timestamps nanoseconde
- Chaque métrique doit être mesurée et enregistrée (ops/sec, latence, RAM, CPU)
- Chaque résultat doit être traçable vers sa source exacte dans le code

## RÈGLE FONDAMENTALE N°3 : INTERDICTION DE SUPPRESSION
- AUCUN module ne peut être retiré du système sans demande explicite
- SEULS des ajouts et mises à jour sont autorisés
- Tous les modules existants doivent rester fonctionnels et testés

## RÈGLE FONDAMENTALE N°4 : MÉTRIQUES OBLIGATOIRES
Pour chaque module, mesurer obligatoirement :
- Temps d'exécution (nanosecondes)
- Débit (opérations/seconde)
- Latence moyenne et maximale
- Usage mémoire (allocation/libération)
- Usage CPU (pourcentage)
- Taux de réussite/échec des tests
- Métriques spécifiques au domaine du module

## RÈGLE FONDAMENTALE N°5 : COUVERTURE EXHAUSTIVE
- Tests unitaires : 100% des fonctions publiques
- Tests d'intégration : tous les modules interconnectés
- Tests de stress : capacités limites de chaque module
- Tests de régression : validation après modifications

## RÈGLE FONDAMENTALE N°6 : DOCUMENTATION DÉTAILLÉE
- Chaque test doit expliquer son objectif et sa méthodologie
- Chaque résultat doit être analysé et commenté
- Chaque anomalie doit être documentée et expliquée
- Comparaisons avec standards industriels obligatoires

## RÈGLE FONDAMENTALE N°7 : VALIDATION CONTINUE
- Tests automatiques à chaque modification
- Rapport complet généré à chaque exécution
- Alertes en cas de régression de performance
- Archivage de tous les résultats historiques