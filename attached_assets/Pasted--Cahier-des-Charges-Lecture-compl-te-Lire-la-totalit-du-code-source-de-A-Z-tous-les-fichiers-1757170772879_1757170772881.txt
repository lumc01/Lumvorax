ğŸ“Œ Cahier des Charges

Lecture complÃ¨te

Lire la totalitÃ© du code source de A Ã  Z (tous les fichiers .c, .h, Makefile, scripts, etc.).

Lire dâ€™abord STANDARD_NAMES.md en entier pour connaÃ®tre les noms normalisÃ©s.

VÃ©rifier que tous les noms utilisÃ©s dans le code respectent STANDARD_NAMES.md.

Gestion des noms

Ne jamais inventer un nouveau nom si un nom standard existe dÃ©jÃ .

Si un Ã©lÃ©ment nâ€™existe pas, crÃ©er un nouveau nom unique et lâ€™ajouter Ã  STANDARD_NAMES.md.

Chaque nouveau nom doit Ãªtre ajoutÃ© avec date + heure au format YYYY-MM-DD HH:MM - nom + description claire.

Garder Ã  jour STANDARD_NAMES.md Ã  chaque modification.

Corrections obligatoires

Supprimer tout placeholder, code mort, ou fonction vide.

Corriger toutes les fonctions incomplÃ¨tes pour quâ€™elles implÃ©mentent un algorithme rÃ©el et standardisÃ© (ex. SHA-256 â†’ RFC6234, mÃ©moire â†’ malloc/free robustes, etc.).

Supprimer tout warning de compilation.

Remplacer les appels incorrects (abs â†’ labs, etc.).

Ajouter les prototypes manquants dans les headers.

Sâ€™assurer que le Makefile est valide (pas de flags inutiles comme -lm sur la compilation objet).

Sâ€™assurer que chaque appel a une implÃ©mentation rÃ©elle derriÃ¨re.

AuthenticitÃ©

Les algorithmes doivent Ãªtre implÃ©mentÃ©s correctement (pas simulÃ©s).

Cryptographie â†’ tester contre vecteurs de rÃ©fÃ©rence (RFC / OpenSSL).

Conversion binaire/LUM â†’ tester avec des exemples rÃ©els.

MÃ©moire â†’ vÃ©rifier allocations/libÃ©rations sans fuite.

ParallÃ©lisme â†’ vÃ©rifier rÃ©sultats identiques en multi-thread.

Validation continue

AprÃ¨s chaque correction, recompiler et relancer les tests unitaires.

Si erreur â†’ recommencer et corriger jusquâ€™Ã  validation.

Produire un rapport complet avant/aprÃ¨s chaque correction avec explication claire (en langage simple, pas seulement technique).

Rapports exigÃ©s

Rapport Markdown numÃ©rotÃ© :

Liste des erreurs trouvÃ©es.

Corrections appliquÃ©es (avant/aprÃ¨s).

Nouveaux noms ajoutÃ©s au STANDARD_NAMES.md.

RÃ©sultats de compilation et exÃ©cution des tests.

Chaque rapport doit inclure : mÃ©triques de performance rÃ©elles, Ã©quivalents standards, et preuves dâ€™exÃ©cution (hash attendu vs obtenu, temps CPU, mÃ©moire consommÃ©e, etc.).

ExÃ©cution obligatoire

Compiler avec make clean && make.

Lancer les tests avec make test ou make run.

Sauvegarder et afficher les logs complets.

En cas dâ€™Ã©chec â†’ recommencer jusquâ€™Ã  ce que Ã§a tourne correctement.

Interdictions

ğŸš« Pas de simplification inutile.

ğŸš« Pas de suppression dâ€™Ã©lÃ©ments avancÃ©s dÃ©jÃ  prÃ©sents (interdiction de rÃ©trograder).

ğŸš« Pas de placeholders ni de fonctions vides.

ğŸš« Pas de sortie â€œthÃ©oriqueâ€ sans exÃ©cution.

ğŸ¯ Objectif final

Obtenir un projet 100% fonctionnel, compilant sans warning, avec des algorithmes rÃ©els et authentiques, validÃ©s par tests.

Un STANDARD_NAMES.md toujours Ã  jour, retraÃ§ant lâ€™historique des crÃ©ations.

Un rapport complet prouvant lâ€™authenticitÃ© et la performance du systÃ¨me.